/******************************************************************************
 *
 * LifeLike - LifeLike computer interfaces
 * Copyright (C) 2007 Sangyoon Lee, Electronic Visualization Laboratory, 
 * University of Illinois at Chicago
 *
 * This software is free software; you can redistribute it and/or modify it 
 * under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either Version 2.1 of the License, or 
 * (at your option) any later version.
 *
 * This software is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public 
 * License for more details.
 * 
 * You should have received a copy of the GNU Lesser Public License along
 * with this software; if not, write to the Free Software Foundation, Inc., 
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
 *
 * Questions or comments about LifeLike should be directed to 
 * cavern@evl.uic.edu
 *
 *****************************************************************************/
/*
/*
-----------------------------------------------------------------------------
Filename:    LifeLike.cpp
-----------------------------------------------------------------------------
This source file is generated by the Ogre AppWizard. Based on the Example 
Framework for OGRE (Object-oriented Graphics Rendering Engine)

Copyright (c) 2000-2007 The OGRE Team
For the latest info, see http://www.ogre3d.org/

Original source code is modified by Sangyoon Lee, Electronic Visualization 
Laboratory, University of Illinois at Chicago
-----------------------------------------------------------------------------
*/

#define _ATL_APARTMENT_THREADED

#ifdef _WINDOWS
#include <atlbase.h>
extern CComModule _Module;
#include <atlcom.h>
#endif

#include "LifeLike.h"
#include "LLCharacter.h"
#include "LLSceneManager.h"
#include "LLMicMonitor.h"
#include "LLScreenLog.h"
#include "LLNavigator.h"
#include "LLActivityManager.h"
#include "LLEmotionProcessor.h"

#include <OgreLight.h>
#include <OgreExternalTextureSourceManager.h>

// global variables
LifeLikeApp* g_pLLApp = NULL;
char *LLDictionaryFile = NULL;

//-----------------------------------------------------------------------------
CEGUI::MouseButton convertOISMouseButtonToCEGUI(int buttonID)
{
    switch (buttonID)
    {
	case 0: return CEGUI::LeftButton;
	case 1: return CEGUI::RightButton;
	case 2:	return CEGUI::MiddleButton;
	case 3: return CEGUI::X1Button;
	default: return CEGUI::LeftButton;
    }
}

//-----------------------------------------------------------------------------
#ifdef _WINDOWS

#include <stdio.h>
#include <fcntl.h>
#include <io.h>
#include <iostream>
#include <string>

void showWin32Console()
{
	static const WORD MAX_CONSOLE_LINES = 5000;
	int hConHandle;
	long lStdHandle;
	CONSOLE_SCREEN_BUFFER_INFO coninfo;
	FILE *fp;
	// allocate a console for this app
	AllocConsole();

	// set the screen buffer to be big enough to let us scroll text
	GetConsoleScreenBufferInfo(GetStdHandle(STD_OUTPUT_HANDLE), &coninfo);
	coninfo.dwSize.Y = MAX_CONSOLE_LINES;
	SetConsoleScreenBufferSize(GetStdHandle(STD_OUTPUT_HANDLE), coninfo.dwSize);
	
	// redirect unbuffered STDOUT to the console
	lStdHandle = (long)GetStdHandle(STD_OUTPUT_HANDLE);
	hConHandle = _open_osfhandle(lStdHandle, _O_TEXT);
	fp = _fdopen( hConHandle, "w" );
	*stdout = *fp;
	setvbuf( stdout, NULL, _IONBF, 0 );

	// redirect unbuffered STDIN to the console
	lStdHandle = (long)GetStdHandle(STD_INPUT_HANDLE);
	hConHandle = _open_osfhandle(lStdHandle, _O_TEXT);
	fp = _fdopen( hConHandle, "r" );
	*stdin = *fp;
	setvbuf( stdin, NULL, _IONBF, 0 );

	// redirect unbuffered STDERR to the console
	lStdHandle = (long)GetStdHandle(STD_ERROR_HANDLE);
	hConHandle = _open_osfhandle(lStdHandle, _O_TEXT);
	fp = _fdopen( hConHandle, "w" );
	*stderr = *fp;
	setvbuf( stderr, NULL, _IONBF, 0 );

	// make cout, wcout, cin, wcin, wcerr, cerr, wclog and clog
	// point to console as well
	std::ios::sync_with_stdio();

	// resize & reposition console window
	HWND hwd = GetConsoleWindow();
	MoveWindow(hwd, 0, 0, 800, 1000, TRUE);

}
#endif

//-----------------------------------------------------------------------------
LifeLikeApp::LifeLikeApp(void)
: mAltDown(false),
	mShiftDown(false),
	mManaged(false), 
	mShouldRotate(false), 
	mShouldTranslate(false), 
	mShouldZoom(false),
	mShouldRotateZ(false),
	mGoodBye(false),
	m_fTipTimer(0.0f),
	m_fCaptionTimer(0.0f),
	m_bCaptionOn(false),
	m_pNavigator(0),
	m_deactiveMicIcon(0),
	m_activeMicIcon(0),
	m_micWaveform(0),
	m_micMeter(0),
	m_tipContentsGUI(0),
	m_tipGUI(0),
	m_captionContentsGUI(0),
	m_captionContentsGUIBG(0),
	m_captionGUI(0),
	mHeadTranslateVector(Vector3::ZERO)
{
	g_pLLApp = this;
}

//-----------------------------------------------------------------------------
LifeLikeApp::~LifeLikeApp(void)
{
	if (mScreenDebugMessage)
		delete mScreenDebugMessage;

	if (m_pLLManager)
		delete m_pLLManager;

	Ogre::LogManager::getSingleton().logMessage( "LifeLikeApp destructor finished!");
}

//-----------------------------------------------------------------------------
void LifeLikeApp::createScene(void)
{
	// load configuration
	String cscreen;
	ConfigFile cf;
	cf.load("LifeLike.cfg");

	// camera parameters
	String camx, camy, camz, lookx, looky, lookz, checkstr;
	camx = cf.getSetting("PosX", "Camera", "0");
	camy = cf.getSetting("PosY", "Camera", "160");
	camz = cf.getSetting("PosZ", "Camera", "50");
	lookx = cf.getSetting("LookX", "Camera", "0");
	looky = cf.getSetting("LookY", "Camera", "130");
	lookz = cf.getSetting("LookZ", "Camera", "0");
	m_InitCamPos[0] = atof(camx.c_str());
	m_InitCamPos[1] = atof(camy.c_str());
	m_InitCamPos[2] = atof(camz.c_str());
	m_InitCamLookAt[0] = atof(lookx.c_str());
	m_InitCamLookAt[1] = atof(looky.c_str());
	m_InitCamLookAt[2] = atof(lookz.c_str());
	
	// initialize GUI system
	Ogre::RenderTarget *mRenderTarget = mWindow;
	mGUIRenderer = &CEGUI::OgreRenderer::bootstrapSystem(*mRenderTarget);
	CEGUI::Logger::getSingleton().setLoggingLevel(CEGUI::Informative);

	// load scheme and set up defaults
	int iScheme = atoi(cf.getSetting("NumScheme", "GUI", "0").c_str());
	if (iScheme != 0)
	{
		char items[128];
		for (int i=0; i<iScheme; i++)
		{
			sprintf(items, "Scheme%i", i);
			
			// this is a bit risky since if there is no such attribute, what happen?
			checkstr = cf.getSetting(items, "GUI", "none");
			if (checkstr.compare("none")==0)
				continue;
			CEGUI::SchemeManager::getSingleton().create(checkstr);
		}
	}

	// mouse UI
	CEGUI::System::getSingleton().setDefaultMouseCursor(cf.getSetting("MouseImageset", "GUI", "TaharezLook"), cf.getSetting("MouseImage", "GUI", "MouseArrow"));
	if (atoi(cf.getSetting("MouseShow", "GUI", "1").c_str()) == 0)
		CEGUI::MouseCursor::getSingleton().hide( );
	
	// layout
	CEGUI::Window* llsheet = CEGUI::WindowManager::getSingleton().loadWindowLayout((CEGUI::utf8*)cf.getSetting("GUILayout", "GUI", "LifeLike.layout").c_str()); 
	CEGUI::System::getSingleton().setGUISheet(llsheet);
	CEGUI::WindowManager& wmgr = CEGUI::WindowManager::getSingleton();
	
	// tooltip
	CEGUI::System::getSingleton().setDefaultTooltip( (CEGUI::utf8*)"TaharezLook/Tooltip" );

	// GUI components
	try
	{
		// mic icon gui
		m_activeMicIcon = (CEGUI::Window*)wmgr.getWindow("LifeLike/ActiveMic");
		m_deactiveMicIcon = (CEGUI::Window*)wmgr.getWindow("LifeLike/DeactiveMic");
		m_micMeter = (CEGUI::ProgressBar*)wmgr.getWindow("LifeLike/MicMeter");
		m_activeMicIcon->hide();
		m_micMeter->disable();

		// tip gui
		m_tipContentsGUI = wmgr.getWindow("LifeLike/Tip/TipContents");
		m_tipGUI = wmgr.getWindow("LifeLike/TipWindow");

		// caption gui
		m_captionContentsGUI = wmgr.getWindow("LifeLike/Caption/CaptionContents");
		m_captionContentsGUIBG = wmgr.getWindow("LifeLike/Caption/CaptionContentsBG");
		m_captionGUI = wmgr.getWindow("LifeLike/CaptionWindow");
	}
	catch (CEGUI::UnknownObjectException  e)
	{
		// well do nothing here
	}

	// dictation for testing purpose
	m_dictationGui = wmgr.getWindow((CEGUI::utf8*)"LifeLike/DictationWindow");

	setupEventHandlers();

	// screen debug logger
	mScreenDebugMessage = new LLScreenLog();
	LLScreenLog::getSingleton().init(mWindow->getWidth(), mWindow->getHeight());

	// LifeLike Custrom Affect Dictionary
	String dictionary;
	dictionary = cf.getSetting("Dictionary", "Affect", "..\\..\\media\\LifeLike\\ll-dictionary11.xml");
	LLDictionaryFile = (char*)dictionary.c_str();

	// LifeLike SceneManager
	m_pLLManager = new LLSceneManager(mSceneMgr);
	m_pLLManager->loadScene();

	// adjust camera a bit (change made 2012.6.5)
	// use camera node instead of direct manipulation of camera so that camera node animation works
	m_pPrimaryCameraNode->setPosition(Vector3(m_InitCamPos[0], m_InitCamPos[1], m_InitCamPos[2]));
	m_pPrimaryCameraNode->lookAt(Vector3(m_InitCamLookAt[0], m_InitCamLookAt[1], m_InitCamLookAt[2]), Node::TransformSpace::TS_WORLD);
	mPrimaryCamera->setFOVy(Degree(15.69f));	// atan((h/2)/d)*2
	

#ifdef _WINDOWS
	// realtime texture for mic icon
	try {
		m_micWaveform = wmgr.getWindow((CEGUI::utf8*)"LifeLike/MicWave");
		if (m_micWaveform)
		{
			CEGUI::Texture& micTexture = mGUIRenderer->createTexture(m_pLLManager->getMicMonitor()->getWaveTexture());
			CEGUI::Imageset& micImageSet = CEGUI::ImagesetManager::getSingleton().create((CEGUI::utf8*)"MicWaveImageset", micTexture);
			micImageSet.defineImage((CEGUI::utf8*)"MicWaveImage", CEGUI::Point(0.0f, 0.0f), micTexture.getSize(), CEGUI::Point(0.0f,0.0f));
			
			m_micWaveform->setProperty("Image", CEGUI::PropertyHelper::imageToString(&micImageSet.getImage((CEGUI::utf8*)"MicWaveImage")));
			m_micWaveform->disable();
			m_micWaveform->hide();
		}
	} catch (CEGUI::UnknownObjectException  e)
	{
		// well do nothing here
	}
	// end of test
#endif
	
	// PAD monitor overlay
	mPADOverlay = Ogre::OverlayManager::getSingleton ().getByName ("LifeLike/ScreenOverlay");
	mPADOverlay->hide ();
	OverlayContainer *pPanel = mPADOverlay->getChild ("PADMonitorPanel");
	pPanel->setMaterialName ("Plane/PADMonitor");

	// cave style navigator
	if (atoi(cf.getSetting("Use", "Navigator", "0").c_str()) == 1)
	{
		camx = cf.getSetting("NavX", "Navigator", "0");
		camy = cf.getSetting("NavY", "Navigator", "0");
		camz = cf.getSetting("NavZ", "Navigator", "100");
		Vector3 navPos = Vector3(StringConverter::parseReal(camx), StringConverter::parseReal(camy), StringConverter::parseReal(camz));
		camx = cf.getSetting("HeadX", "Navigator", "0");
		camy = cf.getSetting("HeadY", "Navigator", "125");
		camz = cf.getSetting("HeadZ", "Navigator", "70");
		Vector3 headPos = Vector3(StringConverter::parseReal(camx), StringConverter::parseReal(camy), StringConverter::parseReal(camz));
		float sb = StringConverter::parseReal(cf.getSetting("ScreenBottom", "Navigator", "110"));
		int sw = StringConverter::parseInt(cf.getSetting("ScreenWidth", "Navigator", "53"));

		m_pNavigator = new LLNavigator(mPrimaryCamera, navPos, headPos);

		m_pNavigator->setScreenWidth(sw);
		m_pNavigator->setScreenBottom(sb);
		
		mHeadTranslateVector = headPos;
		mHeadInitialVector = headPos;
	}

	// hide ogre stat tray by default
	mTrayMgr->hideTrays();

	// ogre material assignment to gui components
	int iMat = atoi(cf.getSetting("NumMaterial", "GUIMateral", "0").c_str());
	if (iMat != 0)
	{
		char items[128];
		char mName[128];
		char iset[128],iname[128];
		char *p_token0, *p_token1;
		char seps[] = ":\n";
		for (int i=0; i<iMat; i++)
		{
			sprintf(items, "Mat%i", i);
			checkstr = cf.getSetting(items, "GUIMateral", "none");
			if (checkstr.compare("none")==0)
				continue;

			sprintf(mName, checkstr.c_str());
			p_token0 = strtok(mName, seps);	// gui name
			p_token1 = strtok(NULL, seps);	// material name

			if(!Ogre::MaterialManager::getSingleton().resourceExists(p_token1))
			{
				// silent fail
				return;
			}

			// retrieve material & texture information
			MaterialPtr tempMat = Ogre::MaterialManager::getSingleton().getByName(p_token1);
			Pass* tempPass = tempMat->getTechnique(0)->getPass(0);
			std::string textureName = tempPass->getTextureUnitState(0)->getFrameTextureName(0);
			Ogre::TexturePtr tptr = Ogre::TextureManager::getSingleton().getByName(textureName);
			

			// check if this texture is loaded or not
			if (tptr.isNull()) {
				// well, should load it manually
				tptr = Ogre::TextureManager::getSingleton().load(textureName, "General");
				if (tptr.isNull())
					continue;
			}

			// account for scale factor
			Matrix4 m = tempPass->getTextureUnitState(0)->getTextureTransform();
            Real scaleX = Vector3(m[0][0], m[1][0], m[2][0]).length();
            Real scaleY = Vector3(m[0][1], m[1][1], m[2][1]).length();

			// name for image and imageset
			sprintf(iset, "%s_imageset", p_token1);
			sprintf(iname, "%s_image", p_token1);

			// find gui component
			try {
				CEGUI::Window* panel = wmgr.getWindow(p_token0);

				// what if cegui already has this image set/
				// i.e. assign a material to multiple gui component
				// then, should assign it without creating imageset/image
				if(!CEGUI::ImagesetManager::getSingleton().isDefined(iset))
				{
					// create cegui texture
					CEGUI::Texture& texture = 
						mGUIRenderer->createTexture(
						(Ogre::TexturePtr)Ogre::TextureManager::getSingleton().getByName(textureName));

					// set imageset and image
					CEGUI::Imageset& imageSet = CEGUI::ImagesetManager::getSingleton().create(iset, texture);
					CEGUI::Size s = texture.getSize();
					imageSet.defineImage(iname, CEGUI::Point(0.0f, 0.0f), CEGUI::Size(texture.getSize().d_width*scaleX, texture.getSize().d_height*scaleY), CEGUI::Point(0.0f,0.0f));

					// assign image to gui component
					panel->setProperty("Image", CEGUI::PropertyHelper::imageToString(&imageSet.getImage((CEGUI::utf8*)iname)));
				}
				else
				{
					// assign image to gui component
					CEGUI::Imageset& imageSet = CEGUI::ImagesetManager::getSingleton().get(iset);
					panel->setProperty("Image", CEGUI::PropertyHelper::imageToString(&imageSet.getImage((CEGUI::utf8*)iname)));
				}
			} 	catch (CEGUI::UnknownObjectException  e)
			{
				// well do nothing here
			}
		}
	}

	// for thesis model: hide glasses by default
	mWindow->getViewport(0)->setMaterialScheme("LL_HIDE");

}



//-----------------------------------------------------------------------------
void LifeLikeApp::setupEventHandlers(void)
{
	// stuff for pain application
	CEGUI::WindowManager& wmgr = CEGUI::WindowManager::getSingleton();
	
	// buttons on left menu screen
	// nicely iterate all child buttons
	try {
		CEGUI::Window* lmenu = wmgr.getWindow((CEGUI::utf8*)"Default_Main_Frame/Left_Menu" );
		int buttoncount = lmenu->getChildCount();
		CEGUI::Window* abutton;
		for (int i=0; i<buttoncount; i++)
		{
			abutton = lmenu->getChildAtIdx(i);
			if (abutton)
				abutton->subscribeEvent(CEGUI::PushButton::EventClicked,
							CEGUI::Event::Subscriber(&LifeLikeApp::menuButtonPressed, this) );
		}
	} catch (CEGUI::UnknownObjectException  e) {}

	// dictation input
	m_dictationInputEditBox = wmgr.getWindow(
				(CEGUI::utf8*)"LifeLike/DictationWindow/Controls/DictationInput" );
	m_dictationInputEditBox->setText("Type text and Enter.");
	m_dictationInputEditBox->subscribeEvent(
					CEGUI::Editbox::EventTextAccepted, 
					CEGUI::Event::Subscriber(&LifeLikeApp::handleDictation, this) );
	
	wmgr.getWindow((CEGUI::utf8*)"LifeLike/DictationWindow")->subscribeEvent(
					CEGUI::FrameWindow::EventCloseClicked,
					CEGUI::Event::Subscriber(&LifeLikeApp::toggleDictationGUI, this) );

}

//-----------------------------------------------------------------------------
bool LifeLikeApp::menuButtonPressed(const CEGUI::EventArgs& e)
{
	// when menu button pressed
	// pass event to activity manager
	// then, each python script handles things to do

	// find the button window
	const CEGUI::MouseEventArgs& me = static_cast<const CEGUI::MouseEventArgs&>(e);

	String value = "GUI:BUTTON:";
	value.append(me.window->getName().c_str());

	LLCharacter* character = m_pLLManager->getCharacter();
	if (character)
	{
		LLActivityManager* amgr = character->getActivityManager();
		if (amgr)
			amgr->broadcastMsg((char*)value.c_str());
	}

	return true;
}

//-----------------------------------------------------------------------------
void LifeLikeApp::setCaptionEntry(char* msg, float duration)
{
	// for multi-language, use | to delim string...
	// let's limit it upto 3 languages
	char msg0[4096];
	strcpy(msg0, msg);
	char newmsg[4096];
	char * tok = NULL;
	tok = strtok(msg0, "#");
	strcpy(newmsg, "");
	while (tok)
	{
		strcat(newmsg, tok);
		strcat(newmsg, "\n\n");
		tok = strtok(NULL, "#");
	}

	if (m_captionContentsGUI)
	{
		m_captionContentsGUI->setText(newmsg);
		m_captionContentsGUIBG->setText(newmsg);
		m_fCaptionTimer = duration;
		m_bCaptionOn = true;
	}
}

//-----------------------------------------------------------------------------
void LifeLikeApp::setTipEntry(char* msg, float duration)
{
	if (m_tipContentsGUI)
	{
		m_tipContentsGUI->setText(msg);

		if (m_tipGUI)
			m_tipGUI->show();

		m_fTipTimer = duration;
	}
}

//-----------------------------------------------------------------------------
void LifeLikeApp::showTipEntry(float duration)
{
		if (m_tipGUI)
			m_tipGUI->show();

		m_fTipTimer = duration;
}

//-----------------------------------------------------------------------------
void LifeLikeApp::setGUIVisible(char* guiName, bool visible)
{
	// find gui component
	try {
		CEGUI::Window* win = CEGUI::WindowManager::getSingleton().getWindow(guiName);
		win->setVisible(visible);
	} catch (CEGUI::UnknownObjectException  e) {}

}

//-----------------------------------------------------------------------------
void LifeLikeApp::setGUITexture(char* guiName, char* materialName)
{
	// apply ogre material to gui component
	char iset[128],iname[128];

	if(!Ogre::MaterialManager::getSingleton().resourceExists(materialName))
	{
		// silent fail
		return;
	}

	// retrieve material & texture information
	MaterialPtr tempMat = Ogre::MaterialManager::getSingleton().getByName(materialName);
	Pass* tempPass = tempMat->getTechnique(0)->getPass(0);
	std::string textureName = tempPass->getTextureUnitState(0)->getFrameTextureName(0);
	Ogre::TexturePtr tptr = Ogre::TextureManager::getSingleton().getByName(textureName);
	
	// check if this texture is loaded or not
	if (tptr.isNull()) {
		// well, should load it manually
		tptr = Ogre::TextureManager::getSingleton().load(textureName, "General");
		if (tptr.isNull())
			return;
	}

	// account for scale factor
	Matrix4 m = tempPass->getTextureUnitState(0)->getTextureTransform();
    Real scaleX = Vector3(m[0][0], m[1][0], m[2][0]).length();
    Real scaleY = Vector3(m[0][1], m[1][1], m[2][1]).length();

	// name for image and imageset
	sprintf(iset, "%s_imageset", materialName);
	sprintf(iname, "%s_image", materialName);

	// find gui component
	try {
		CEGUI::Window* panel = CEGUI::WindowManager::getSingleton().getWindow(guiName);

		// what if cegui already has this image set/
		// i.e. assign a material to multiple gui component
		// then, should assign it without creating imageset/image
		if(!CEGUI::ImagesetManager::getSingleton().isDefined(iset))
		{
			// create cegui texture
			CEGUI::Texture& texture = 
				mGUIRenderer->createTexture(
				(Ogre::TexturePtr)Ogre::TextureManager::getSingleton().getByName(textureName));

			// set imageset and image
			CEGUI::Imageset& imageSet = CEGUI::ImagesetManager::getSingleton().create(iset, texture);
			CEGUI::Size s = texture.getSize();
			imageSet.defineImage(iname, CEGUI::Point(0.0f, 0.0f), CEGUI::Size(texture.getSize().d_width*scaleX, texture.getSize().d_height*scaleY), CEGUI::Point(0.0f,0.0f));

			// assign image to gui component
			panel->setProperty("Image", CEGUI::PropertyHelper::imageToString(&imageSet.getImage((CEGUI::utf8*)iname)));
		}
		else
		{
			// assign image to gui component
			CEGUI::Imageset& imageSet = CEGUI::ImagesetManager::getSingleton().get(iset);
			panel->setProperty("Image", CEGUI::PropertyHelper::imageToString(&imageSet.getImage((CEGUI::utf8*)iname)));
		}
	} 	catch (CEGUI::UnknownObjectException  e)
	{
		// well do nothing here
	}

}

//-----------------------------------------------------------------------------
void LifeLikeApp::setMicVisible(bool visible)
{
	if (!m_activeMicIcon)
		return;
	
	if (visible)
	{
		m_activeMicIcon->show();
		m_deactiveMicIcon->hide();
		m_micMeter->enable();
	}
	else
	{
		m_activeMicIcon->hide();
		m_deactiveMicIcon->show();
		m_micMeter->disable();
		m_micWaveform->disable();
		m_micMeter->setProgress(0);
	}
}

//-----------------------------------------------------------------------------
void LifeLikeApp::setMicMeter(float value)
{
	if (m_micMeter)
		m_micMeter->setProgress(value);
}

//-----------------------------------------------------------------------------
void LifeLikeApp::setMaterialMsg(char* matName, char* msg, char* param)
{
	// the original format MAT:MSG:Pain/Monitor:play_mode:restart
	// here parameters are material name, message (play_mode), parameter (restart)
	ExternalTextureSource* extex = ExternalTextureSourceManager::getSingleton().getExternalTextureSource("ogg_video");
	if (extex)
	{
		char cmd[256];
		sprintf(cmd, "%s\t%s", param, matName);
		extex->setParameter(msg, cmd);
	}
}

//-----------------------------------------------------------------------------
bool LifeLikeApp::frameStarted(const FrameEvent& evt)
{

	// Move about 100 units per second,
	mMoveScale = mMoveSpeed * evt.timeSinceLastFrame;
	// Take about 10 seconds for full rotation
	mRotScale = mRotateSpeed * evt.timeSinceLastFrame;
	
	return true;
}

//-----------------------------------------------------------------------------
bool  LifeLikeApp::frameRenderingQueued(const FrameEvent& evt)
{
	// logic elapsed time capture
	unsigned long before = Root::getSingleton().getTimer()->getMilliseconds();

	if(mWindow->isClosed())
		return false;

	const Ogre::Real addedTime = evt.timeSinceLastFrame;

	unsigned int ht = mWindow->getHeight();
	unsigned int wd = mWindow->getWidth();

	
	//Need to capture/update each device
	mKeyboard->capture();
	mMouse->capture();

	mUseBufferedInputMouse = mMouse->buffered();
	mUseBufferedInputKeys = mKeyboard->buffered();

	if(mUseBufferedInputMouse)
	{
	 //CEGUI::MouseCursor::getSingleton().show( );
	}
	else
	{
	 CEGUI::MouseCursor::getSingleton().hide( );
	}

	if (mTimeUntilNextToggle >= 0)
		mTimeUntilNextToggle -= evt.timeSinceLastFrame;

	if (mUseBufferedInputKeys)
	{
		// no need to do any processing here, it is handled by event processor and
		// you get the results as KeyEvents
	}
	else
	{
		if (processUnbufferedKeyInput(evt) == false)
		{
			return false;
		}
	}
	if (mUseBufferedInputMouse)
	{
		// no need to do any processing here, it is handled by event processor and
		// you get the results as MouseEvents
	}
	else
	{
		if (processUnbufferedMouseInput(evt) == false)
		{
			return false;
		}
	}

	m_pLLManager->update(addedTime);
	
	// update tip guid
	if (m_fTipTimer > 0.0f)
	{
		if (m_fTipTimer < 0.0f)
		{
			m_fTipTimer = 0.0f;
			if (m_tipGUI)
				m_tipGUI->hide();
		}
	}

	// jim's caption
	if (m_bCaptionOn && !m_pLLManager->isSpeaking())
	{
		m_fCaptionTimer += addedTime;
		if (m_fCaptionTimer > 3.0f)
		{
			m_fCaptionTimer = 0.0f;
			m_bCaptionOn = false;

			if (m_captionContentsGUI)
			{
				m_captionContentsGUI->setText("");
				m_captionContentsGUIBG->setText("");
			}
		}
	}

	mTrayMgr->frameRenderingQueued(evt);

    if (!mTrayMgr->isDialogVisible())
    {
        if (mDetailsPanel->isVisible())   // if details panel is visible, then update its contents
        {
            mDetailsPanel->setParamValue(0, Ogre::StringConverter::toString(mPrimaryCamera->getDerivedPosition().x));
            mDetailsPanel->setParamValue(1, Ogre::StringConverter::toString(mPrimaryCamera->getDerivedPosition().y));
            mDetailsPanel->setParamValue(2, Ogre::StringConverter::toString(mPrimaryCamera->getDerivedPosition().z));
            mDetailsPanel->setParamValue(4, Ogre::StringConverter::toString(mPrimaryCamera->getDerivedOrientation().w));
            mDetailsPanel->setParamValue(5, Ogre::StringConverter::toString(mPrimaryCamera->getDerivedOrientation().x));
            mDetailsPanel->setParamValue(6, Ogre::StringConverter::toString(mPrimaryCamera->getDerivedOrientation().y));
            mDetailsPanel->setParamValue(7, Ogre::StringConverter::toString(mPrimaryCamera->getDerivedOrientation().z));
			mDetailsPanel->setParamValue(9, Ogre::StringConverter::toString(Degree(mPrimaryCamera->getFOVy())));
        }
    }

	//
	if ( CEGUI::System::getSingletonPtr() )
		CEGUI::System::getSingleton().injectTimePulse( evt.timeSinceLastFrame );

	return true;
}

//-----------------------------------------------------------------------------
bool LifeLikeApp::frameEnded(const FrameEvent& evt)
{
	if (mShutdownRequested)
		return false;

	return true;
}

//-----------------------------------------------------------------------------
bool LifeLikeApp::processUnbufferedKeyInput(const FrameEvent& evt)
{
	if (mGoodBye)
	{
		if (m_pLLManager->isSpeaking())
			return true;
		else
		{
			return false;
		}
	}

	using namespace OIS;
	OIS::Keyboard* mInputDevice = mKeyboard; // Nice hack, eh? :)

	if( mInputDevice->isKeyDown( KC_ESCAPE)  && mTimeUntilNextToggle <= 0 )
	{
		mGoodBye = true;
		mTimeUntilNextToggle = 0.5;
	}

	// Animation Speed change
	if( mInputDevice->isKeyDown( KC_MULTIPLY)  && mTimeUntilNextToggle <= 0)
	{
		m_pLLManager->setAnimationSpeed(1.0f);
		mTimeUntilNextToggle = 0.5;
	}
	if( mInputDevice->isKeyDown( KC_DIVIDE)  && mTimeUntilNextToggle <= 0)
	{
		m_pLLManager->setAnimationSpeed(0.0f);
		mTimeUntilNextToggle = 0.5;
	}
	if( mInputDevice->isKeyDown( KC_SUBTRACT) && mTimeUntilNextToggle <= 0)
	{
		m_pLLManager->setAnimationSpeed(-0.2f * evt.timeSinceLastFrame, true);
		mTimeUntilNextToggle = 0.05;
	}
	if( mInputDevice->isKeyDown( KC_ADD) && mTimeUntilNextToggle <= 0)
	{
		m_pLLManager->setAnimationSpeed(0.2f * evt.timeSinceLastFrame, true);
		mTimeUntilNextToggle = 0.05;
	}
	// end of Animation Speed change

	// Render State
	if (mInputDevice->isKeyDown(KC_DECIMAL) && mTimeUntilNextToggle <=0)
	{
		mSceneDetailIndex = (mSceneDetailIndex+1)%3 ;
		switch(mSceneDetailIndex) {
				case 0 : mPrimaryCamera->setPolygonMode(PM_SOLID) ; break ;
				case 1 : mPrimaryCamera->setPolygonMode(PM_WIREFRAME) ; break ;
				case 2 : mPrimaryCamera->setPolygonMode(PM_POINTS) ; break ;
		}
		mTimeUntilNextToggle = 0.5;
	}
	
	// Profile Screen
	if (mInputDevice->isKeyDown(KC_F11) && mTimeUntilNextToggle <= 0)
	{
		if (!mTrayMgr->areTraysVisible())
		{
			mTrayMgr->showTrays();
		}
		else
		{
			mTrayMgr->hideTrays();
		}
		mTimeUntilNextToggle = 0.5;
	}

	// Debug Overlay
	static bool displayDebugDetails = false;
	if (mInputDevice->isKeyDown(KC_F12) && mTimeUntilNextToggle <= 0)
	{
		displayDebugDetails = !displayDebugDetails;
		mScreenDebugMessage->showOverlay(displayDebugDetails);
		mTimeUntilNextToggle = 0.5;
	}

	// Debug Overlay
	static bool displayPADOverlay = false;
	if (mInputDevice->isKeyDown(KC_F10) && mTimeUntilNextToggle <= 0)
	{
		displayPADOverlay = !displayPADOverlay;
		if (displayPADOverlay)
			mPADOverlay->show();
		else
			mPADOverlay->hide();

		mTimeUntilNextToggle = 0.5;
	}

	// alt key
	if (mInputDevice->isKeyDown(KC_LMENU))
		mAltDown = true;
	else
		mAltDown = false;

	// shift key
	if (mInputDevice->isKeyDown(KC_LSHIFT))
		mShiftDown = true;
	else
		mShiftDown = false;
	
	// SAPI test
	if (mInputDevice->isKeyDown(KC_F1) && mTimeUntilNextToggle <= 0)
	{
		m_pLLManager->speak(0, "hello my name is Alexander Schwarzkopf");
		mTimeUntilNextToggle = 0.5;
	}
	if (mInputDevice->isKeyDown(KC_F2) && mTimeUntilNextToggle <= 0)
	{
		m_pLLManager->speak(0, "Normal grants are received by the NSF <silence msec=\"100\"/> and generally must address both the what <silence msec=\"100\"/> and the how <silence msec=\"100\"/> of the research that's to be enter tained or undertaken.  And it is very important that in addressing this <silence msec=\"100\"/> you not only state what you want to do but how your gonna do it <silence msec=\"500\"/> and generally one of the things most researchers fail to do is address the how they're going to do it <silence msec=\"100\"/> as compared to what they're going to do.");
		mTimeUntilNextToggle = 0.5;
	}
	if (mInputDevice->isKeyDown(KC_F3) && mTimeUntilNextToggle <= 0)
	{
		int nChar = m_pLLManager->getNumCharacters();
		for (int i=0; i<nChar; i++)
			m_pLLManager->stopSpeak(i);

		mTimeUntilNextToggle = 0.5;
	}
	static int waveCounter = 0;
	if (mInputDevice->isKeyDown(KC_F4) && mTimeUntilNextToggle <= 0)
	{
		char tstr[8];
		sprintf(tstr, "%d", waveCounter);
		waveCounter++;
		if (waveCounter > 119)
			waveCounter = 0;
		m_pLLManager->speak(0, tstr, CSP_WAVE);
		mTimeUntilNextToggle = 0.5;
	}

	// camera reset
	if (mInputDevice->isKeyDown(KC_HOME) && mTimeUntilNextToggle <= 0)
	{
		if (m_pNavigator)
		{
			mHeadTranslateVector = mHeadInitialVector;
			m_pNavigator->reset();
		}
		else
		{
			// reset camera
			m_pPrimaryCameraNode->setPosition(Ogre::Vector3(m_InitCamPos[0], m_InitCamPos[1], m_InitCamPos[2]));
			m_pPrimaryCameraNode->lookAt(Ogre::Vector3(m_InitCamLookAt[0], m_InitCamLookAt[1], m_InitCamLookAt[2]), Node::TransformSpace::TS_WORLD);
		
			// reset model transformation
			m_pLLManager->resetOrientation();
		}

		mTimeUntilNextToggle = 0.5;
	}
	
	// rendering style
	if (mInputDevice->isKeyDown(KC_R) && mTimeUntilNextToggle <=0)
	{
		mSceneDetailIndex = (mSceneDetailIndex+1)%3 ;
		switch(mSceneDetailIndex) {
				case 0 : mPrimaryCamera->setPolygonMode(PM_SOLID) ; break ;
				case 1 : mPrimaryCamera->setPolygonMode(PM_WIREFRAME) ; break ;
				case 2 : mPrimaryCamera->setPolygonMode(PM_POINTS) ; break ;
		}
		mTimeUntilNextToggle = 0.5;
	}
	static int schemehigh = 0;
	if (mInputDevice->isKeyDown(KC_L) && mTimeUntilNextToggle <=0)
	{
		Viewport* vp = mWindow->getViewport(0);

		mTimeUntilNextToggle = 0.5;
		if (schemehigh == 0)
			vp->setMaterialScheme("LL_Flat");
		else if (schemehigh == 1)
			vp->setMaterialScheme("LL_No_Reflection");
		else if (schemehigh == 2)
			vp->setMaterialScheme("default");

		schemehigh = (schemehigh + 1) % 3;
	}
	static int schemehide = 1;
	if (mInputDevice->isKeyDown(KC_O) && mTimeUntilNextToggle <=0)
	{
		Viewport* vp = mWindow->getViewport(0);

		mTimeUntilNextToggle = 0.5;
		if (schemehide == 0)
			vp->setMaterialScheme("LL_HIDE");
		else if (schemehide == 1)
			vp->setMaterialScheme("default");
		schemehide = (schemehide + 1) % 2;

	}
	static int schemehair = 0;
	if (mInputDevice->isKeyDown(KC_P) && mTimeUntilNextToggle <=0)
	{
		Viewport* vp = mWindow->getViewport(0);

		mTimeUntilNextToggle = 0.5;
		if (schemehair == 0)
			vp->setMaterialScheme("LL_HAIR_NOMOTION");
		if (schemehair == 1)
			vp->setMaterialScheme("LL_HAIR_SINE");
		else if (schemehair == 2)
			vp->setMaterialScheme("LL_HAIR_ADVANCED");
		else if (schemehair == 3)
			vp->setMaterialScheme("default");	// this is the most advanced using head orientation
		schemehair = (schemehair + 1) % 4;

	}


	// Process key input in SceneManager
	m_pLLManager->processKeyInput(mInputDevice);

	// navigator test
	if (m_pNavigator)
	{
		// move navigator
		if (mInputDevice->isKeyDown(KC_UP) || mInputDevice->isKeyDown(KC_NUMPAD8) )
			mTranslateVector.z = -mMoveScale*0.5;
		if (mInputDevice->isKeyDown(KC_DOWN) || mInputDevice->isKeyDown(KC_NUMPAD5) )
			mTranslateVector.z = mMoveScale*0.5;
		if (mInputDevice->isKeyDown(KC_RIGHT) || mInputDevice->isKeyDown(KC_NUMPAD9) )
			mTranslateVector.x = mMoveScale*0.5;
		if (mInputDevice->isKeyDown(KC_LEFT) || mInputDevice->isKeyDown(KC_NUMPAD7) )
			mTranslateVector.x = -mMoveScale*0.5;

		m_pNavigator->moveNavigator(mTranslateVector);
		mTranslateVector = Ogre::Vector3::ZERO;

		// rotate navigator
		if (mInputDevice->isKeyDown(KC_NUMPAD4) )
			m_pNavigator->rotateNavigator(-mRotScale.valueDegrees()*0.2);
		if (mInputDevice->isKeyDown(KC_NUMPAD6) )
			m_pNavigator->rotateNavigator(mRotScale.valueDegrees()*0.2);


		if (mInputDevice->isKeyDown(KC_W))
			mHeadTranslateVector.z -= mMoveScale*0.2f;
		if (mInputDevice->isKeyDown(KC_S))
			mHeadTranslateVector.z += mMoveScale*0.2f;
		if (mInputDevice->isKeyDown(KC_D))
			mHeadTranslateVector.x += mMoveScale*0.2f;
		if (mInputDevice->isKeyDown(KC_A))
			mHeadTranslateVector.x -= mMoveScale*0.2f;

		mHeadTranslateVector = m_pNavigator->setHeadPosition(mHeadTranslateVector);
	}
	else
	{
		// move camera
		if (mInputDevice->isKeyDown(KC_UP) || mInputDevice->isKeyDown(KC_NUMPAD8) )
			mTranslateVector.z = -mMoveScale;
		if (mInputDevice->isKeyDown(KC_DOWN) || mInputDevice->isKeyDown(KC_NUMPAD5) )
			mTranslateVector.z = mMoveScale;
		if (mInputDevice->isKeyDown(KC_RIGHT) || mInputDevice->isKeyDown(KC_NUMPAD9) )
			mTranslateVector.x = mMoveScale*0.5;
		if (mInputDevice->isKeyDown(KC_LEFT) || mInputDevice->isKeyDown(KC_NUMPAD7) )
			mTranslateVector.x = -mMoveScale*0.5;

		if (mTranslateVector.length() != 0.0)
		{
			// compute correct camera translation
			Quaternion qt = m_pPrimaryCameraNode->getOrientation();
			mTranslateVector = qt*mTranslateVector;
			mTranslateVector.y = 0.0f;
			m_pPrimaryCameraNode->translate(mTranslateVector);
		}
		mTranslateVector = Ogre::Vector3::ZERO;

		// rotate camera
		if (mInputDevice->isKeyDown(KC_NUMPAD4) )
			m_pPrimaryCameraNode->yaw(mRotScale*0.2);
		if (mInputDevice->isKeyDown(KC_NUMPAD6) )
			m_pPrimaryCameraNode->yaw(-mRotScale*0.2);
		if (mInputDevice->isKeyDown(KC_PGUP) )
			m_pPrimaryCameraNode->pitch(mRotScale*0.2);
		if (mInputDevice->isKeyDown(KC_PGDOWN) )
			m_pPrimaryCameraNode->pitch(-mRotScale*0.2);

	}

	// Dictation GUI
	if (mInputTypeSwitchingOn && mInputDevice->isKeyDown(KC_F9) && mTimeUntilNextToggle <= 0)
	{
		// must be going from immediate keyboard to buffered keyboard
		switchKeyMode();
		mTimeUntilNextToggle = 1;

		if (mUseBufferedInputKeys)
		{
			// show chat gui
			m_dictationGui->show();
			if (!CEGUI::MouseCursor::getSingleton().isVisible())
				CEGUI::MouseCursor::getSingleton().show( );
		}
	}
	// end of Dictation GUI

	// Return true to continue rendering
	return true;
}

//-----------------------------------------------------------------------------
bool LifeLikeApp::keyPressed( const OIS::KeyEvent &arg )
{
	if( arg.key == OIS::KC_ESCAPE )
	{
		mGoodBye = true;
		
		// change keyinput mode
		mUseBufferedInputKeys = false;
		mKeyboard->setBuffered(mUseBufferedInputKeys);

	}
	CEGUI::System::getSingleton().injectKeyDown( arg.key );
	CEGUI::System::getSingleton().injectChar( arg.text );
	return true;
}

//-----------------------------------------------------------------------------
bool LifeLikeApp::keyReleased( const OIS::KeyEvent &arg )
{
	if (arg.key == OIS::KC_SYSRQ)
	{
		std::ostringstream ss;
		ss << "screenshot_" << ++mNumScreenShots << ".png";
		mWindow->writeContentsToFile(ss.str());
	}

	CEGUI::System::getSingleton().injectKeyUp( arg.key );
	return true;
}

//-----------------------------------------------------------------------------
bool LifeLikeApp::mouseMoved( const OIS::MouseEvent &arg )
{
	CEGUI::System::getSingleton().injectMouseMove(arg.state.X.rel, arg.state.Y.rel);
	CEGUI::System::getSingleton().injectMouseWheelChange(arg.state.Z.rel); 
	if (mManaged) 
	{
		return true;
	} 
	else
	{
		static const float mul = 0.2; //1
		// rotation
		if (mShouldRotate) 
		{
			if (m_pNavigator)
			{
				m_pNavigator->rotateNavigator(-arg.state.X.rel * mul);
			}
			else
			{
				Quaternion deltaq;
				Real delta, dy, dx;
				Vector3 cmaRight, camDir;
				if (dy = arg.state.Y.rel) 
				{
					delta = dy * mul;
					deltaq.FromAngleAxis(Degree(delta), Vector3::UNIT_X);

					m_pLLManager->rotate(deltaq);
				}

				if (dx = arg.state.X.rel) 
				{
					delta = dx * mul;
					deltaq.FromAngleAxis(Degree(delta), Vector3::UNIT_Y);

					m_pLLManager->rotate(deltaq);
				}
			}
		}
		// translation
		else if (mShouldTranslate) 
		{
			if (m_pNavigator)
			{
				Vector3 mv(-arg.state.X.rel*mul, arg.state.Y.rel*mul,0);
				m_pNavigator->moveNavigator(mv);
			}
			else
			{
				// move camera instead of root node
				m_pPrimaryCameraNode->translate(Vector3(-arg.state.X.rel*mul, arg.state.Y.rel*mul, 0), Node::TransformSpace::TS_LOCAL);
			}
		}
		// zoom
		else if (mShouldZoom)
		{
			if (m_pNavigator)
			{
				Vector3 mv(0, 0 , -arg.state.Y.rel*mul);
				m_pNavigator->moveNavigator(mv);
			}
			else
			{
				// move camera instead of root node
				m_pPrimaryCameraNode->translate(Vector3(0, 0 , -arg.state.Y.rel*mul), Node::TransformSpace::TS_LOCAL);
			}
		}
		// another zoom for wheel
		else if (mAltDown && arg.state.Z.rel !=0)
		{
			if (m_pNavigator)
			{
				Vector3 mv(0, 0 , -arg.state.Z.rel*mul);
				m_pNavigator->moveNavigator(mv);
			}
			else
			{
				// move camera instead of root node
				m_pPrimaryCameraNode->translate(Vector3(0, 0 , -arg.state.Z.rel*mul), Node::TransformSpace::TS_LOCAL);
			}
		}
	}

	// extra stuff: testing...
	unsigned int wd = mWindow->getWidth();
	unsigned int ht = mWindow->getHeight();
	float fx = (float) arg.state.X.abs / (float) arg.state.width;
	float fy = (float) arg.state.Y.abs / (float) arg.state.height;

	// there is some need for scene manager know for this mouse movement: i.e. move picked object
	if (arg.state.buttonDown(OIS::MouseButtonID::MB_Left))
		m_pLLManager->mouseMoved(arg.state.X.rel, arg.state.Y.rel);

	return true;
}

//-----------------------------------------------------------------------------
bool LifeLikeApp::mousePressed( const OIS::MouseEvent &arg, OIS::MouseButtonID id )
{
	CEGUI::System::getSingleton().injectMouseButtonDown(convertOISMouseButtonToCEGUI(id));
	
	if (! mManaged && mAltDown) 
    {
		mShouldRotate = (id == OIS::MB_Left);
		mShouldTranslate = (id == OIS::MB_Middle);
		mShouldZoom = (id == OIS::MB_Right);
	}

	// dirty hack to use dictation without interfereing move event
	//if (!mAltDown)
	if (!mAltDown && !m_dictationGui->isVisible())
		m_pLLManager->processMouseInput(arg, (int)id, 1);

	return true;
}

//-----------------------------------------------------------------------------
bool LifeLikeApp::mouseReleased( const OIS::MouseEvent &arg, OIS::MouseButtonID id )
{
	bool consumed = CEGUI::System::getSingleton().injectMouseButtonUp(convertOISMouseButtonToCEGUI(id));

	if (! mManaged) 
	{
		if (id == OIS::MB_Left) 
			mShouldRotate = false;
		if (id == OIS::MB_Middle) 
			mShouldTranslate = false;
		if (id == OIS::MB_Right)
			mShouldZoom = false;
	}

	if (id == OIS::MB_Left && !consumed)
		m_pLLManager->processMouseInput(arg, (int)id, 0);

	return true;

}

//-----------------------------------------------------------------------------
bool LifeLikeApp::handleDictation(const CEGUI::EventArgs& e)
{
	// we got new chat message from user!
	if (m_dictationInputEditBox->getText().length() != 0)
	{
		// speak
		m_pLLManager->speak(0, m_dictationInputEditBox->getText().c_str());
		m_dictationInputEditBox->setText("");
	}

	return true;
}

//-----------------------------------------------------------------------------
bool LifeLikeApp::toggleDictationGUI(const CEGUI::EventArgs& e)
{
	if(m_dictationGui->isVisible())
	{
		// hide chat gui
		m_dictationGui->hide();
		
		// change keyinput mode
		mUseBufferedInputKeys = false;
		mKeyboard->setBuffered(mUseBufferedInputKeys);
	}
	else
	{
		// this should not happen
	}
	
	return true;
}

//-----------------------------------------------------------------------------
void LifeLikeApp::go(void)
{
	if (!setup())
		return;

	showDebugOverlay(false);

	mRoot->startRendering();

	// clean up
	destroyScene();
}




//-----------------------------------------------------------------------------
#ifdef __cplusplus
	extern "C" {
#endif
  
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
		INT WINAPI WinMain( HINSTANCE hInst, HINSTANCE, LPSTR strCmdLine, INT )
#else
		int main(int argc, char *argv[])
#endif
		{

#ifdef _DEBUG
			showWin32Console();
#endif
			// Create application object
			LifeLikeApp app;
			
			try {
				app.go();
			} catch( Ogre::Exception& e ) {
#if OGRE_PLATFORM == OGRE_PLATFORM_WIN32
				MessageBox( NULL, e.getFullDescription().c_str(), "An exception has occured!", MB_OK | MB_ICONERROR | MB_TASKMODAL);
#else
				std::cerr << "An exception has occured: " <<
					e.getFullDescription().c_str() << std::endl;
#endif
			}
			
#ifdef _DEBUG
			FreeConsole();
#endif
			return 0;
		}

#ifdef __cplusplus
	}
#endif
